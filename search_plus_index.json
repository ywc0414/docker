{"./":{"url":"./","title":"前言","keywords":"","body":"Docker简介 Docker是一个开源的容器化平台，用于开发、构建、打包和运行应用程序。它可以将应用程序和其依赖项打包在一起，形成一个独立的容器，从而实现跨平台和快速部署的目的。 Docker有以下几个核心概念： 镜像（Image）：Docker镜像是一个只读的模板，用于创建Docker容器。镜像可以包含应用程序、依赖项、库、环境设置等。 容器（Container）：Docker容器是由Docker镜像创建的可运行实例。容器是独立、可移植和可部署的，可以在任何Docker环境中运行。 仓库（Repository）：Docker仓库是用于存储和分享Docker镜像的中心化存储库。Docker Hub是最常用的公共Docker仓库。 Docker的优点包括： 轻量级：Docker容器相对于虚拟机而言更加轻量级，启动比较快，占用的资源较少。 可移植性：Docker容器可以在任何Docker环境中运行，从而实现跨平台的目的。 高效性：Docker镜像可以重复使用，节省了部署和配置的时间和成本。 安全性：Docker容器提供了隔离和安全性，使得每个容器都可以独立运行，不会对其他容器造成影响。 总之，Docker为开发人员和运维人员提供了一种简单、快速、便携和可扩展的方法来构建、交付和运行应用程序。 "},"第1章 Docker Engine/1.1 centos安装docker.html":{"url":"第1章 Docker Engine/1.1 centos安装docker.html","title":"1.1 centos安装docker","keywords":"","body":"卸载旧版本的docker yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装yum-uitls工具 yum install -y yum-utils 设置docker的yum源（阿里云） yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 查看仓库中所有docker版本 yum list docker-ce --showduplicates | sort -r 安装docker yum install docker-ce docker-ce-cli containerd.io 也可以安装指定版本 yum install docker-ce docker-ce-cli containerd.io 配置镜像加速及修改默认存储路径 docker的默认存储路径：/var/lib/docker 创建daemon.json：vim /etc/docker/daemon.json { # 设置私有仓库地址（http） \"insecure-registries\": [\"192.168.1.238:5000\"], # 阿里云的镜像加速地址 \"registry-mirrors\": [\"https://23evy2ba.mirror.aliyuncs.com\"], # 设置docker的默认存储路径 \"data-root\": \"/home/docker\", # Docker远程管理，可以结合portainer WEB管理工具一起使用 \"hosts\": [\"tcp://0.0.0.0:2375\", \"unix:///var/run/docker.sock\"], # 官方推荐使用systemd，非常不建议使用cgroupfs \"exec-opts\": [\"native.cgroupdriver=systemd\"], # 设置为阿里的dns（默认为谷歌的：8.8.8.8和8.8.4.4） \"dns\": [\"223.5.5.5\", \"223.6.6.6\"], # 设置docker日志文件 \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"100m\", \"max-file\": \"10\" }, # Docker推荐使用overlay2作为Storage driver \"storage-driver\": \"overlay2\", \"storage-opts\":[\"overlay2.override_kernel_check=true\"], # 设置/dev/shm的大小，默认值是64M \"default-shm-size\": \"128M\", # pull镜像的最大并行数，默认为3个 \"max-concurrent-downloads\": 10, # push镜像的最大并行数，默认为5个 \"max-concurrent-uploads\": 10 } 常用配置daemon.json { \"registry-mirrors\": [\"https://m2bdyhi7.mirror.aliyuncs.com\"], \"dns\": [\"223.5.5.5\", \"223.6.6.6\"], \"data-root\": \"/data/docker\", \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"100m\", \"max-file\": \"3\" }, \"max-concurrent-downloads\": 10, \"max-concurrent-uploads\": 10 } 重新加载配置并启动docker systemctl daemon-reload systemctl start docker systemctl enable docker docker的常用命令 设置docker开机自启动：docker 进入容器内：docker exec -it id/name bash 查看容器所有信息：docker inspect id/name 查看容器进程：docker top id/name 查看容器端口：docker port id/name 查看容器IP：docker exec -it id/name ip addr 查看容器资源使用情况：docker stats 查看容器网路情况：docker network ls "},"第1章 Docker Engine/1.2 ubuntu安装docker.html":{"url":"第1章 Docker Engine/1.2 ubuntu安装docker.html","title":"1.2 ubuntu安装docker","keywords":"","body":"卸载旧版本 apt-get remove docker docker-engine docker.io containerd runc 更新安装依赖 apt-get update 安装依赖包 apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common 安装秘钥 curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 设置docker源（阿里云） add-apt-repository \\ \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" 更新安装依赖 apt-get update 查看仓库中所有docker版本 apt-cache madison docker-ce 安装docker apt install docker-ce docker-ce-cli containerd.io 也可以安装指定版本 apt install docker-ce docker-ce-cli containerd.io 配置镜像加速及修改默认存储路径 docker的默认存储路径：/var/lib/docker 创建daemon.json： vim /etc/docker/daemon.json { # 设置私有仓库地址（http） \"insecure-registries\": [\"192.168.1.238:5000\"], # 阿里云的镜像加速地址 \"registry-mirrors\": [\"https://23evy2ba.mirror.aliyuncs.com\"], # 设置docker的默认存储路径 \"data-root\": \"/home/docker\", # Docker远程管理，可以结合portainer WEB管理工具一起使用 \"hosts\": [\"tcp://0.0.0.0:2375\", \"unix:///var/run/docker.sock\"], # 官方推荐使用systemd，非常不建议使用cgroupfs \"exec-opts\": [\"native.cgroupdriver=systemd\"], # 设置为阿里的dns（默认为谷歌的：8.8.8.8和8.8.4.4） \"dns\": [\"223.5.5.5\", \"223.6.6.6\"], # 设置docker日志文件 \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"100m\", \"max-file\": \"10\" }, # Docker推荐使用overlay2作为Storage driver \"storage-driver\": \"overlay2\", \"storage-opts\":[\"overlay2.override_kernel_check=true\"], # 设置/dev/shm的大小，默认值是64M \"default-shm-size\": \"128M\", # pull镜像的最大并行数，默认为3个 \"max-concurrent-downloads\": 10, # push镜像的最大并行数，默认为5个 \"max-concurrent-uploads\": 10 } 重新加载配置并启动docker systemctl daemon-reload systemctl start docker systemctl enable docker docker的常用命令 设置docker开机自启动：docker 进入容器内：docker exec -it id/name bash 查看容器所有信息：docker inspect id/name 查看容器进程：docker top id/name 查看容器端口：docker port id/name 查看容器IP：docker exec -it id/name ip addr 查看容器资源使用情况：docker stats 查看容器网路情况：docker network ls "},"第1章 Docker Engine/1.3 离线安装docker.html":{"url":"第1章 Docker Engine/1.3 离线安装docker.html","title":"1.3 离线安装docker","keywords":"","body":"一，下载docker的离线安装包 centos 7.9下载地址 # 下载containerd.io wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.6.9-3.1.el7.x86_64.rpm # 下载docker-ce-cli wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-cli-26.1.3-1.el7.x86_64.rpm # 下载docker-ce wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-26.1.3-1.el7.x86_64.rpm ubuntu 22.04下载地址 # 下载containerd.io wget https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/containerd.io_1.4.6-1_amd64.deb # 下载docker-ce-cli wget https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/docker-ce-cli_20.10.7~3-0~ubuntu-xenial_amd64.deb # 下载docker-ce wget https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/docker-ce_20.10.7~3-0~ubuntu-xenial_amd64.deb 二，安装docker centos 7.9 # 安装顺序：containerd.io-->docker-ce-cli-->docker-ce # 安装containerd.io rpm -ivh containerd.io-1.6.9-3.1.el7.x86_64.rpm # 安装docker-ce-cli rpm -ivh docker-ce-cli-26.1.3-1.el7.x86_64.rpm # 安装docker-ce rpm -ivh docker-ce-26.1.3-1.el7.x86_64.rpm ubuntu 20.04 # 安装顺序：containerd.io-->docker-ce-cli-->docker-ce # 安装containerd.io dpkg -i containerd.io_1.4.6-1_amd64.deb # 安装docker-ce-cli dpkg -i docker-ce-cli_20.10.7~3-0~ubuntu-xenial_amd64.deb # 安装docker-ce dpkg -i docker-ce_20.10.7~3-0~ubuntu-xenial_amd64.deb 三，配置docker 设置配置文件:(vi /etc/docker/daemon.json) { # 设置docker的默认存储路径 \"data-root\": \"/data/docker\", # 设置docker日志文件 \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"100m\", \"max-file\": \"10\" } } 四，启动docker # 重新加载配置并启动docker systemctl daemon-reload systemctl start docker systemctl enable docker "},"第2章 Docker Image/2.1 镜像的基础命令.html":{"url":"第2章 Docker Image/2.1 镜像的基础命令.html","title":"2.1 镜像的基础命令","keywords":"","body":"查询镜像 docke search redis 拉取镜像 # 当前没指定tag时，默认拉取最新的（latest） docker pull redis # 拉取指定版本的镜像 docker pull redis:4.0.8 查看已拉取的镜像 docker images 给镜像打tag # docker tag 源tag 目标tag docker tag redis:4.0.8 myredis:v1 查看镜像详情 docker inspect redis:4.0.8 查看镜像构建历史 docker history redis:4.0.8 删除镜像 # 删除镜像时，需要先删除引用了该镜像的容器 docker rmi redis:4.0.8 "},"第2章 Docker Image/2.2 镜像的导出导入.html":{"url":"第2章 Docker Image/2.2 镜像的导出导入.html","title":"2.2 镜像的导出导入","keywords":"","body":"导出镜像 docker save -o my-zookeeper.tar zookeeper:3.8.1 查看命令帮助 docker save --help -o 或者 --output ：指定生成的文件 标准输出的语法： docker save zookeeper:3.8.1 > my-zookeeper.tar 生成的tar文件在当前目录 导入镜像 将tar文件拷贝到另外台主机，执行以下命令执行导入 docker load -i my-zookeeper.tar 查看命令帮助 docker load --help -i 或者 ---input：指定加载的文件 -q 或者 --quiet：省略打印的信息 标准输入语法： docker load options参数：只能写成-qi，不能写成-iq，i后面要紧跟着要加载的文件 "},"第3章 Docker Container/3.1 容器的基础命令.html":{"url":"第3章 Docker Container/3.1 容器的基础命令.html","title":"3.1 容器的基础命令","keywords":"","body":"创建容器 # 创建容器 docker create --name nginx_container nginx:1.19.0 # 创建并运行容器 docker run -d --name nginx_container nginx:1.19.0 --rm：容器退出后，自动删除容器及数据挂载卷，相当于执行命令：docker rm -v -i：标准输入 -t：分配个伪终端tty -p：端口 -d：容器后台运行 -v：挂载 --restart=always：开机自启动 --privileged=true：拥有root权限 --name：容器名称 nginx:1.19.0：镜像名称 停止容器 docker stop nginx_container 启动容器 docker start nginx_container 重启容器 docker restart nginx_container 删除容器 docker rm -v nginx_container 进入容器 # 进入容器内 docker exec -it nginx_caontainer bash # 远程执行容器内的命令 docker exec container_name ls /home # 将本地的数据库备份文件导入到数据库容器内 docker exec -i container_name mysql --login-path=root@local 查看容器详情 docker inspect nginx_container 复制容器文件 # 将本地的文件复制到容器内 docker cp /home/aaa.txt container_name:/home/ # 将容器内的文件复制到本地 docker cp container_name:/home/aaa.txt /home/ 查看容器资源使用情况 docker stats "},"第3章 Docker Container/3.2 部署centos容器.html":{"url":"第3章 Docker Container/3.2 部署centos容器.html","title":"3.2 部署centos容器","keywords":"","body":"拉取镜像 docker pull centos:7 运行容器 docker run -d --privileged=true --name centos7 centos:7 /usr/sbin/init --rm：容器退出后，自动删除容器及数据挂载卷，相当于执行命令：docker rm -v -i：标准输入 -t：分配个伪终端tty -p：端口 -d：容器后台运行 --privileged：拥有root权限 --name：容器名称 centos:7：镜像名称 /usr/sbin/init：可以使用systemctl服务管理 进入容器 # 进入容器 docker exec -it centos7 bash # 查询是否安装lrzsz yum list lrzsz rpm -q lrzsz # 安装lrzsz yum install lrzsz 提交容器 docker commit -a \"yangwencheng\" -c \"installed lrzsz\" centos7 mycentos:1.0.0 docker commit --help -a：作者 -m：描述 推送至镜像仓库 # 登录镜像仓库 docker login xxx.xxx.xx # 推送镜像 docker push xxx.xxx.xx/xxx/mycentos:1.0.0 "},"第3章 Docker Container/3.3 容器的提交.html":{"url":"第3章 Docker Container/3.3 容器的提交.html","title":"3.3 容器的提交","keywords":"","body":"应用场景 比如：我用docker跑了台centos的服务器，由于centos镜像中缺失很多命令工具，类似于纯净版， 那么我们可以在运行的容器内安装好软件工具，然后将此容器进行提交（commit）成新的镜像， 共享给其他人用； 容器的提交 docker commit -a \"zhangsan\" -m \"installed lrzsz\" centos_container mycentos:v1 查看镜像详情：docker inspect imagesID 查看命令帮助 docker commit --help -a 或者 --author：作者 -c 或者 --change：Dockerfile CMD -m 或者 --message：commit message -p 或者 --pause：pause container "},"第3章 Docker Container/3.4 容器的导出导入.html":{"url":"第3章 Docker Container/3.4 容器的导出导入.html","title":"3.4 容器的导出导入","keywords":"","body":"容器的导出 docker export -o mynginx.tar nginx_container 查看命令帮助 docker export --help -o 或者 --output ：指定生成的文件 容器的导人 将tar文件拷贝到另外台主机，执行以下命令执行导入 docker import mynginx.tar mynginx:v1 docker save 与 docker export的区别 export作用于容器，save作用于镜像，但他们导出的结果都为tar文件； export一次只能针对一个容器进行导出，save一次可以对多个镜像进行导出； export只是对当前的容器的文件系统快照进行导出，其会丢弃原镜像的所有历史记录与元数据信息，save则是保存了原镜像的完整记录 docker load 与 docker import的区别 import导入的是容器包，load加载的是镜像包，但最终都会恢复为镜像； import恢复为的镜像只包含当前镜像一层，load恢复的镜像与原镜像是完全相同的（docker history imageID）； import恢复的镜像就是新构建的，与原镜像的imageID不同，load恢复的镜像与原镜像是同一个，即imageID相同； import可以为导入的镜像指定repository:tag，load加载的镜像不能指定repository:tag，与原镜像的相同； "},"第4章 Docker Volume/4.1 volume简介.html":{"url":"第4章 Docker Volume/4.1 volume简介.html","title":"4.1 volume简介","keywords":"","body":"一，简介 ​ Docker Volume 是 Docker 中用于持久化数据的一种机制。它允许在容器和主机之间共享和管理数据。Docker Volume 的主要目的是解决容器中数据持久化的需求，以便在容器的生命周期内保留数据，并且在容器重新创建或迁移时能够方便地访问和使用数据。 二，应用场景 数据持久化： 容器在重新创建时，可以使用 Docker Volume 存储的数据来保留状态和配置信息。这对于数据库容器或其他需要持久化数据的应用程序非常有用。 数据共享： 多个容器可以通过 Docker Volume 共享数据，以便它们之间可以交换信息或协同工作。 备份和恢复： 使用 Docker Volume 可以轻松备份容器中的数据，并在需要时进行恢复。 数据迁移： 通过将 Docker Volume 与容器解耦，可以轻松地迁移容器和数据，而无需担心数据丢失或损坏。 三，类型 匿名卷（Anonymous Volume）： 这些卷没有显式指定名称，由 Docker 自动生成，并且与容器的生命周期绑定。当容器被删除时，匿名卷也会被删除。 命名卷（Named Volume）： 这些卷由用户显式指定名称，并且可以在容器之间共享和重用。命名卷的生命周期独立于容器，因此即使容器被删除，命名卷的数据仍然存在。 绑定挂载（Bind Mount）： 这种类型的卷将主机文件系统中的特定路径绑定到容器中的路径，容器可以直接访问主机上的文件或目录。使用 Docker Volume 可以通过 Docker CLI 或 Docker Compose 进行操作和管理。可以创建、列出、删除和查看 Docker Volume，并将其与容器关联。 "},"第4章 Docker Volume/4.2 数据卷挂载.html":{"url":"第4章 Docker Volume/4.2 数据卷挂载.html","title":"4.2 数据卷挂载","keywords":"","body":"创建数据卷 docker volume creat test_volume 数据卷创建成功后，所在路径为默认安装路径（/var/lib/docker）： /var/lib/docker/volumes 查询数据卷列表 docker volume ls 查看数据卷详情 docker volume inspect test_volume 删除数据卷 docker volume rm test_volume 挂载数据卷 # 命名式挂载（当删除容器时：docker rm -v centos_test,数据卷不会被删除） docker run -id --name centos_test -v test_volume:/opt/test centos:7 # 匿名式挂载（当删除容器时：docker rm -v centos_test,数据卷会被删除） docker run -id --name centos_test -v /opt/test centos:7 "},"第4章 Docker Volume/4.3 文件目录挂载.html":{"url":"第4章 Docker Volume/4.3 文件目录挂载.html","title":"4.3 文件目录挂载","keywords":"","body":"创建挂载目录 mkdir /opt/aaa 挂载目录 docker run -id --name centos_test -v /opt/aaa:/opt/aaa centos:7 挂载文件 # 进入挂载目录 cd /opt/aaa # 创建需要挂载的文件 echo \"username:zhangsan\" > user.txt # 挂载文件 docker run -id --name centos_test -v /opt/aaa/user.txt:/opt/aaa/my.txt centos:7 "},"第5章 Docker Network/5.1 docker网络简介.html":{"url":"第5章 Docker Network/5.1 docker网络简介.html","title":"5.1 docker网络简介","keywords":"","body":"一，概述 Docker容器每次重启后容器IP是会发生变化的。这也意味着如果容器间使用ip地址来进行通信的话，一旦有容器重启，重启的容器将不再能被访问到。 而Docker 网络就能够解决这个问题。 Docker 网络主要有以下两个作用： 容器间的互联和通信以及端口映射 容器IP变动时候可以通过服务名直接网络通信而不受到影响 二，网络模式 模式名称 命令指定方式 描述 bridge --network bridge 为每一个容器分配、设置 ip ，并将容器连接到 docker0 虚拟网桥上，这也是默认网络模式 host --network host 容器不会创建自己的网卡，配置 ip 等，而是使用宿主机的 ip 和端口 container --network 容器名或id 新创建的容器不会创建自己的网卡和配置自己的ip，而是和一个指定的容器共享ip、端口范围 none --network none 容器有独立的Network namespace，但并没有对其进行任何网络设置 --network和--net命令是一样的，--net是简写 docker安装完成后，会自动创建三个网络：bridge，host，none 桥接模式-bridge Docker服务启动 时，默认会创建一个名称为 docker0 网桥（其上有一个名称为 docker0 内部接口）。该桥接网络的名称为docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker会 默认指定docker0 的 ip地址和子网掩码，让主机和容器之间可以通过网桥相互通信。 主机模式-host 不创建任何网络接口，直接使用宿主机的 ip地址与外界进行通信，不再需要额外进行NAT转换。 容器模式-container 新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的ip，而是和一个指定的容器共享ip、端口范围等。两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。 none模式 在none模式下，并不为Docker容器进行任何网络配置。 "},"第5章 Docker Network/5.2 docker网络命令.html":{"url":"第5章 Docker Network/5.2 docker网络命令.html","title":"5.2 docker网络命令","keywords":"","body":"一，基础命令 创建网络 # 基础用法 docker network create mynet # 创建网络时是可以添加一系列参数的： # --driver：网络模式 # --gateway：主子网的IPV4和IPV6的网关 # --subnet：代表网段的CIDR格式的子网 # mynet：自定义网络名称 docker network create --driver=bridge --gateway=192.168.10.1 --subnet=192.168.10.0/24 mynet 不指定任何选项的时候默认的--driver(网络模式)也是bridge(桥接)，但是gateway和subnet会自动生成 查看网络列表 docker network ls 查看网络详情 docker network inspect mynet 断开已连接的网络 # 断开容器container_name中的网络network_name docker network disconnect network_name container_name 连接网络 # 将网络network_name连接到容器container_name中，并设置固定IP docker network connect network_name --ip 192.168.xx.xx container_name 删除不在使用的网络 docker network prune 删除网络 docker network rm mynet 二，使用示例 创建一个容器并指定网络及IP # 创建网络 docker network create --driver=bridge --gateway=192.168.10.1 --subnet=192.168.10.0/24 mynet # 创建容器 docker run -it --name centos7 --net mynet --ip 192.168.10.10 centos:7 使用docker-compose给多个容器使用同一网络 创建容器 # 创建网络 docker network create --driver=bridge --gateway=192.168.10.1 --subnet=192.168.10.0/24 mynet 编写docker-compose.yml version: '3' services: nginx: image: nginx:1.19.0 container_name: nginx_container restart: always privileged: true volumes: - /home/compose/web/conf/nginx.conf:/etc/nginx/nginx.conf - /home/compose/web/www:/etc/nginx/www environment: - TZ=Asia/Shanghai networks: my_network: ipv4_address: 192.168.10.2 ports: - 80:80 mysql: image: mysql:8.0.20 container_name: mysql_container restart: always privileged: true volumes: - /home/compose/mysql/my.cnf:/etc/mysql/my.cnf - /home/compose/mysql/data/:/var/lib/mysql - /home/compose/mysql/conf.d:/etc/mysql/conf.d - /etc/localtime:/etc/localtime:ro environment: MYSQL_ROOT_PASSWORD: \"123456\" MYSQL_ROOT_HOST: \"%\" TZ: Asia/Shanghai networks: my_network: ipv4_address: 192.168.10.3 ports: - 3306:3306 redis: image: redis:4.0.8 container_name: redis_container restart: always volumes: - /home/compose/redis/redis.conf:/etc/redis/redis.conf - /home/compose/redis/data:/data command: /bin/bash -c \"redis-server /etc/redis/redis.conf\" environment: - TZ=Asia/Shanghai networks: my_network: ipv4_address: 192.168.10.4 ports: - 6379:6379 也可以在docker-compose里配置networks，自动创建网络 networks: mynet: driver: bridge ipam: config: - subnet: \"192.168.10.1/24\" gateway: 192.168.10.1 # version '3'时不需要配置，否则会报错，version '2'时才需要配 将容器加入到已经存在的网络 networks: my_network: external: name: mynet "},"第6章 Dockerfile/6.1 Dockerfile参数介绍.html":{"url":"第6章 Dockerfile/6.1 Dockerfile参数介绍.html","title":"6.1 Dockerfile参数介绍","keywords":"","body":"指令详解 FROM 描述 功能为指定基础镜像，并且必须是第一条指令。如果不以任何镜像为基础，那么写法为：FROM scratch。同时意味着接下来所写的指令将作为镜像的第一层开始。 语法 FROM FROM : FROM : # 三种写法，其中和 是可选项，如果没有选择，那么默认值为latest MAINTAINER 描述 指定作者 语法 MAINTAINER 新版本docker使用LABEL指明 LABEL 描述 指定标签 语法 LABEL = = = ... LABEL maintainer=\"xxxx\" email=\"xxx@163.com\" # 如果太长，建议使用换行符\"\\\" LABEL maintainer=\"xxxx\" \\ email=\"xxx@163.com\" \\ description=\"xxxxxxx\" # 一个Dockerfile种可以有多个LABEL LABEL maintainer=\"xxxx\" LABEL email=\"xxx@163.com\" LABEL description=\"xxxxxxx\" LABEL会继承基础镜像种的LABEL，如遇到key相同，则值会被覆盖 ADD 描述 把文件添加到镜像中 语法 ADD ... # 目录（将该目录下所有文件添加到目标目录下） ADD /opt/test /opt/testDir # 文件 ADD test.jar /opt/test.jar # 压缩文件（添加过去后会自动解压） ADD test.tar.gz /opt # url ADD http://www.xxx.com/test /opt 路径的填写可以是容器内的绝对路径，也可以是相对于工作目录的相对路径，推荐写成绝对路径 可以是一个本地文件或者是一个本地压缩文件，还可以是一个url 如果把写成一个url，那么ADD就类似于wget命令 src为一个目录的时候，会自动把目录下的文件复制过去，目录本身不会复制 如果src为多个文件，dest一定要是一个目录 COPY 描述 把文件复制到镜像中 语法 功能与ADD类似 区别： COPY的只能是本地文件 COPY如果是压缩文件，不会自动解压 EXPOSE 描述 暴漏容器运行时的监听端口给外部 语法 EXPOSE EXPOSE 8080 EVN 描述 设置环境变量 语法 # 设置单个 ENV # 设置多个 ENV = ... ENV MYSQL_ROOT_PASSWORD=\"123456\" MYSQL_ROOT_HOST=\"localhost\" RUN 描述 构建镜像时执行的命令 语法 # 直接运行shell命令 RUN RUN yum install -y net-tools lrzsz unzip # 类似于函数调用（可将exec理解成为可执行文件，后面就是两个参数） RUN [\"executable\", \"param1\", \"param2\"] CMD 描述 容器启动时默认命令或参数 语法 CMD [\"executable\",\"param1\",\"param2\"] CMD [ \"sh\", \"-c\", \"echo $HOME\" CMD [\"param1\",\"param2\"] CMD [ \"echo\", \"$HOME\" ] CMD command param1 param2 CMD date RUN和CMD的却别 RUN：构建镜像时执行的命令 CMD：构建时指定，容器运行时执行的命令 ENTRYPOINT 描述 容器启动时运行得启动命令 语法 # 执行shell命令 ENTRYPOINT command param1 param2 # 执行带参数的可执行文件 ENTRYPOINT [\"executable\", \"param1\", \"param2\"] ENTRYPOINT和CMD的区别 CMD只能写一条，如果写了多条，会被覆盖 ENTRYPOINT不会被覆盖 如果我们在Dockerfile种同时写了ENTRYPOINT和CMD，并且CMD指令不是一个完整的可执行命令，那么CMD指定的内容将会作为ENTRYPOINT的参数 VOLUME 描述 指定挂载卷 语法 VOLUME /var/log /var/db USER 描述 指定启动容器的用户 语法 # 指定用户名称 USRE emery # 指定UID USER UID 如果设置了容器以emery用户去运行，那么RUN, CMD 和 ENTRYPOINT 都会以这个用户去运行, 使用这个命令一定要确认容器中拥有这个用户，并且拥有足够权限 WORKDIR 描述 设置工作目录 语法 WORKDIR /opt/aaa "},"第6章 Dockerfile/6.2 构建centos镜像.html":{"url":"第6章 Dockerfile/6.2 构建centos镜像.html","title":"6.2 构建centos镜像","keywords":"","body":"编写Dockerfile # OS版本 FROM centos:7 # 源数据 LABEL maintainer=\"yangwencheng\" email=\"cheng2guen@163.com\" # 设置时区为东8区 ENV TZ=\"Asia/Shanghai\" # 安装基础软件 RUN yum install -y net-tools openssh-server vim lrzsz unzip 构建镜像 docker build -t cetntos:7.0.0 . docker build [options] -t：指定tag名称 -f：指定Dockerfile文件（docker build -f Dockerfile_centos -t centos:7.0.0 .） 当未指定-f参数时，文件名必须为Dockerfile "},"第6章 Dockerfile/6.3 构建ubuntu镜像.html":{"url":"第6章 Dockerfile/6.3 构建ubuntu镜像.html","title":"6.3 构建ubuntu镜像","keywords":"","body":"编写Dockerfile # OS版本 FROM ubuntu:20.04 # 源数据 LABEL maintainer=\"yangwencheng\" email=\"cheng2guen@163.com\" # 设置时区为东8区 ENV TZ=\"Asia/Shanghai\" # 安装基础软件 RUN apt update && apt install -y systemd ssh net-tools vim lrzsz unzip 构建镜像 docker build -t ubuntu:20.0.0 . docker build [options] -t：指定tag名称 -f：指定Dockerfile文件（docker build -f Dockerfile_ubuntu -t ubuntu:20.0.0 .） 当未指定-f参数时，文件名必须为Dockerfile "},"第6章 Dockerfile/6.4 构建springboot镜像.html":{"url":"第6章 Dockerfile/6.4 构建springboot镜像.html","title":"6.4 构建springboot镜像","keywords":"","body":"项目打包 # -DskipTests：打包时跳过测试 mvn clean package -DskipTests 编写Dockerfile #jdk版本 FROM java:8 # 源数据 LABEL maintainer=\"yangwencheng\" email=\"cheng2guen@163.com\" #设置时区为东8区 ENV TZ=\"Asia/Shanghai\" #指定源包，前者是你的jar包 ADD target/bootstrap-2.0.jar app.jar #指定容器启动时执行的命令 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] 构建镜像 docker build -t img_tag . 运行容器 docker run -d --name container_name -v /etc/localtime:/etc/localtime:ro -v /opt:/opt -p http_port:http_port img_tag -d：后台运行 container_name：容器名称 /etc/localtime/ro：同步容器与宿主机的时区（只读） /opt：挂载目录 http_port：端口映射 img_tag：镜像名称 "},"第7章 Docker Compose/7.1 docker-compose简介.html":{"url":"第7章 Docker Compose/7.1 docker-compose简介.html","title":"7.1 docker-compose简介","keywords":"","body":"简介 Docker Compose 是一个用于定义和运行多个 Docker 容器的工具。它使用简单的 YAML 文件来配置应用程序的服务、网络和卷，并提供了一种一次性定义、构建和启动整个应用程序环境的方式 功能及特点 声明式语法： Docker Compose 使用 YAML 文件来定义应用程序的服务、网络和卷。这种声明式语法使得配置变得简单和可读，并且可以轻松地与版本控制系统集成。 多容器应用管理： Docker Compose 允许您定义和管理由多个 Docker 容器组成的应用程序。您可以指定每个容器的映像、环境变量、依赖关系、网络设置等。 服务和依赖管理： 使用 Docker Compose，您可以定义应用程序的服务，并指定它们之间的依赖关系。这使得在启动应用程序时，Docker Compose 可以自动处理容器之间的依赖关系，并按正确的顺序启动它们。 扩展性和复制: Docker Compose 支持通过指定容器的副本数量来扩展服务。您可以简单地指定要创建的副本数，Docker Compose 将会启动并管理这些副本。 网络和卷管理: Docker Compose 允许您定义和管理应用程序的网络和卷。您可以指定容器之间的网络连接方式以及容器与主机之间的卷挂载。 环境变量和配置文件管理: Docker Compose 支持从环境变量、配置文件或命令行参数中读取配置。这使得应用程序的配置变得灵活和可配置。 简化的部署: Docker Compose 可以轻松地将您的应用程序从开发环境部署到生产环境。只需将 Compose 文件与应用程序的映像一起传输到目标环境，然后使用 Docker Compose 启动它们。 "},"第7章 Docker Compose/7.2 docker-compose安装.html":{"url":"第7章 Docker Compose/7.2 docker-compose安装.html","title":"7.2 docker-compose安装","keywords":"","body":"安装方式一 下载docker-compose ``bash sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-uname -s-uname -m` > /usr/local/bin/docker-compose sudo curl -L http://get.daocloud.io/docker/compose/releases/download/v2.32.2/docker-compose-`uname -s-uname -m` > /usr/local/bin/docker-compose sudo curl -L \"https://github.com/docker/compose/releases/download/v2.21.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose - 添加可执行权限 ```bash sudo chmod +x /usr/local/bin/docker-compose 创建软连接 sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 查看版本 docker-compose --version 安装方式二 安装pip（如果尚未安装） sudo yum install -y epel-release sudo yum install -y python-pip 使用pip安装docker-compose sudo pip install docker-compose 查看版本 docker-compose --version "},"第7章 Docker Compose/7.3 docker-compose参数介绍.html":{"url":"第7章 Docker Compose/7.3 docker-compose参数介绍.html","title":"7.3 docker-compose参数介绍","keywords":"","body":"docker-compose常用字段介绍 字段 描述 build 指定Dockerfile文件名（要指定的Dockerfile文件需要在build标签的子级标签中用dockerfile标签指定） dockerfile 构建镜像上下文路径 context 可以是dockerfile路径，或者是执行git 仓库的url地址 image 指定镜像（已存在） command 执行命令，会覆盖容器启动后默认执行的命令（会覆盖Dockerfile的CMD指令） container_name 指定容器名称，由于容器名称是唯一的，如果指定自定义名称，则无法scale指定容器数量 deploy 指定部署和运行服务相关配置，只能在Swarm模式使用 environment 添加环境变量 networks 加入网络，引用顶级networks下条目 network-mode 设置容器的网络模式 ports 暴露容器端口，与-p 相同，但是端口不能低于60 volumes 挂载一个宿主机目录或命令卷到容器，命名卷要在顶级volumes 定义卷名称 hostname 在容器内设置内核参数 links 连接到另一个容器，- 服务名称[ : ] privileged 用来给容器root权限，注意是不安全的，true depends_on 此标签用于解决容器的依赖，启动先后问题。如启动应用容器，需要先启动数据库容器 restart 重启策略：定义是否重启容器；1.no，默认策略，在容器退出时不重启容器。2.on-failure，在容器非正常退出时（退出状态非0），才会重启容器。3.on-failure：3，在容器非正常退出时重启容器，最多重启3次。4.always，在容器退出时总是重启容器。5.unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器 编写docker-compose.yml version: '3' services: api: # 服务名称 build: context: . # Dockerfile文件路径 dockerfile: Dockerfile # Dockerfile文件名 image: java:dockerfile # 镜像名称(来自于dockerfile构建) container_name: admin_container # 容器名称 restart: always # 重启策略: 开机自启动 privileged: true # 拥有权限 environment: TZ: Asia/Shanghai # 指定时区 logging: # 容器日志设置 driver: \"json-file\" options: max-size: \"100m\" max-file: \"3\" volumes: # 挂载文件 - /etc/localtime:/etc/localtime:ro ports: # 映射端口 - 8010:8010 command: [ # 执行的命令 'java', '-jar', '/home/api/admin/admin-2.0.jar' ] 一般情况下，docker-compose.yml为默认文件名，如果要用其他名称，需要加参数-f指定； 需要在docker-compose.yml当前目录下才可以执行命令； 常用的docker-compose.yml version: '3.3' services: jmsapp: image: jumpserver/jms_all container_name: jumpserver-app restart: unless-stopped environment: TZ: Asia/Shanghai SECRET_KEY: astIa5UHZOZrLvdHJvMXNe3fTqYGHadTirdm3t6RCKOKmshoJn #随机key BOOTSTRAP_TOKEN: cZ81fejs8Ftqf1Ru #随机token DB_HOST: jmsdb DB_PORT: 3306 DB_USER: jmsapp DB_PASSWORD: dbJMS@pp DB_NAME: jmsapp REDIS_HOST: jmsredis REDIS_PORT: 6379 REDIS_PASSWORD: redisJMS@pp networks: jms_network: ipv4_address: 192.168.10.2 volumes: - jms_volume:/opt/jumpserver/data - koko_volume:/opt/koko/data - kael_volume:/opt/kael/data - lion_volume:/opt/lion/data - chen_volume:/opt/chen/data ports: - \"8080:80\" #web端口 - \"2222:2222\" #ssh端口 depends_on: - jmsdb - jmsredis jmsdb: image: linuxserver/mariadb container_name: jumpserver-db restart: unless-stopped environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: JMS@pp MYSQL_DATABASE: jmsapp #需和DB_NAME一致 MYSQL_USER: jmsapp #需和DB_USER一致 MYSQL_PASSWORD: dbJMS@pp #需和DB_PASSWORD一致 networks: jms_network: ipv4_address: 192.168.10.3 volumes: - mariadb_volume:/config expose: - 3306 jmsredis: image: redis container_name: jumpserver-redis restart: unless-stopped environment: TZ: Asia/Shanghai networks: jms_network: ipv4_address: 192.168.10.4 volumes: - redis_volume:/data command: redis-server --requirepass redisJMS@pp #设置redis的密码，需和REDIS_PASSWORD一致 expose: - 6379 volumes: jms_volume: external: true name: jumpserver networks: jms_network: external: true name: jms_net docker-compose的常用命令 # 创建并启动容器 docker-compose up # 后台启动 docker-compose up -d # 后台启动并指定服务 docker-compose up -d service_name # 关闭并移除容器 docker-compose down # 列出正在运行的容器 docker-compose ps # 列出所有容器（包括停止的） docker-compose ps -a # 停止容器 docker-compose stop # 开启容器 docker-compose start # 重启容器 docker-compose start # 进入容器 docker-compose exec service_name bash # 查看日志 # docker-compsoe -f: 指定文件名称为docker-compose_xxx.yml # -f：实时动态更新 # --tail=200：显示末尾200行 # system：服务名称 docker-compsoe -f docker-compose_xxx.yml logs -f --tail=200 system "},"第8章 Docker Registry/8.1 注册DockerHub.html":{"url":"第8章 Docker Registry/8.1 注册DockerHub.html","title":"8.1 注册DockerHub","keywords":"","body":"注册dockerhub账号 注册地址：https://hub.docker.com/ 注册成功后，创建repository 给现有的镜像创建tag docker tag redis:4.0.8 dockerhub/repository:tag 推送镜像至dockerhub # 登录dockerhub docker login # 登出docker hub docker logout # 推送镜像 docker push dockerhub/repository:tag "},"第8章 Docker Registry/8.2 搭建Registry.html":{"url":"第8章 Docker Registry/8.2 搭建Registry.html","title":"8.2 搭建Registry","keywords":"","body":"一，拉取镜像 docker pull registry:2.8.1 二，创建用户认证 创建认证目录 mkdir /home/compose/registry/auth 安装htpasswd工具 yum -y install httpd-tools 使用htpasswd来生成用户名和密码 htpasswd -Bbn emery 123 >> /home/compose/registry/auth/htpasswd 三，创建相关目录 # 存放镜像 /home/compose/registry/data:/var/lib/registry # 存放SSL证书 /home/compose/registry/certs:/certs # 存放用户名和密码 /home/compose/registry/auth:/auth 四，创建docker-compose.yml version: '3' services: registry: image: registry:2.8.1 container_name: registry_container restart: always environment: REGISTRY_HTTP_TLS_CERTIFICATE: /certs/9556117_registry.xxx.com.pem REGISTRY_HTTP_TLS_KEY: /certs/9556117_registry.xxx.com.key REGISTRY_AUTH: htpasswd REGISTRY_AUTH_HTPASSWD_PATH: /auth/htpasswd REGISTRY_AUTH_HTPASSWD_REALM: Registry Realm REGISTRY_STORAGE_DELETE_ENABLED: \"true\" # 删除 volumes: - /home/compose/registry/data:/var/lib/registry - /home/compose/registry/certs:/certs - /home/compose/registry/auth:/auth ports: - 5000:5000 五，配置Nginx反向代理 注意：由于registry配置了https，nginx在做反向代理时，转发到的是https location / { proxy_pass https://192.168.0.3:5000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } 六，创建容器 # 创建并启动容器 docker-compose up -d registry # 停止容器 docker-compose stop registry # 删除容器 docker-compose rm registry 七，registry相关命令 # 登录仓库 docker login regsitry.xxx.com # 登出仓库 docker logout regsitry.xxx.com # 拉取镜像 docker pull regsitry.xxx.com/redis:4.0.8 # 推送镜像 docker push regsitry.xxx.com/redis:4.0.8 # 镜像仓库查看地址 https://registry.xxx.com/v2/_catalog 八，docker配置说明 创建daemon.json： vi /etc/docker/daemon.json { # 阿里云镜像加速 \"registry-mirrors\": [\"https://xxxx.mirror.aliyuncs.com\"], # 若没配置https，则需要加上以下配置 \"insecure-registries\": [\"192.168.0.3:5000\"] } "},"第8章 Docker Registry/8.3 搭建Harbor.html":{"url":"第8章 Docker Registry/8.3 搭建Harbor.html","title":"8.3 搭建Harbor","keywords":"","body":"一，下载harbor 安装harbor时，必须先安装docker和docker-compose wget https://github.com/goharbor/harbor/releases/download/v2.8.1/harbor-offline-installer-v2.8.1.tgz 二，解压harbor tar -zxvf harbor-offline-installer-v2.8.1.tgz -C /usr/local/ 三，生成配置 cd /usr/local/harbor ./prepare 四，安装harbor ./install.sh "},"第9章 Docker Software/9.1 部署Nginx.html":{"url":"第9章 Docker Software/9.1 部署Nginx.html","title":"9.1 部署Nginx","keywords":"","body":"一，拉取镜像 docker pull nginx:1.19.0 二，创建docker-compose.yml version: '3' services: nginx: # ngxin容器 image: nginx:1.19.0 # 指定镜像 container_name: nginx_container # 容器名为nginx_container restart: always # 重启策略: 容器退出时总是重启容器 volumes: # 挂载文件 - /home/compose/nginx/conf/nginx.conf:/etc/nginx/nginx.conf - /home/compose/nginx/conf/conf.d:/etc/nginx/conf/conf.d - /home/compose/nginx/www:/etc/nginx/www environment: TZ: Asia/Shanghai ports: # 映射端口 - 80:80 - 443:443 创建挂载目录 # 用于存放前端项目 mkdir /home/compose/nginx/www # 用于存放nginx的配置文件 mkdir /home/compose/nginx/conf 创建配置文件nginx.conf：vim /home/compose/nginx/conf/nginx.conf # 一般设置主机的CPU核心数，也可以设置为自动：auto worker_processes auto; # 指定错误日志文位置， warn：警告，crit：严重错误 error_log /var/log/nginx/error.log warn; # 指定 Nginx 主进程的 PID 文件位置。 pid /var/run/nginx.pid; events { # 默认1024，增加可连接数：10240 worker_connections 10240; } http { # 包含 MIME 类型配置文件，用于告诉 Nginx 不同文件类型的正确 MIME 类型。 include mime.types; # 设置默认的 MIME 类型，当 Nginx 无法确定文件类型时使用。 default_type application/octet-stream; # 定义了一个名为 main 的日志格式，用于记录访问日志。 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; # 设置访问日志的位置、格式 access_log /var/log/nginx/access.log main; # 开启高效文件传输模式，直接从磁盘读取文件到网络，减少内存拷贝 sendfile on; # 开启此选项后，Nginx 将尝试发送完整的 TCP 包，而不是尽可能快地发送数据。 tcp_nopush on; # 关闭 Nagle 算法，立即发送小包，适合交互式应用。 tcp_nodelay on; # 设置客户端连接保持活动的时间，单位是秒。 keepalive_timeout 60s; # 设置类型哈希表的最大大小。 types_hash_max_size 4096; # 限制每次调用 sendfile() 函数传输的数据量，防止占用过多资源。 sendfile_max_chunk 512K; # 设置缓存中文件描述符的有效时间。 open_file_cache_valid 80s; # 设置在缓存有效时间内，文件最少被访问的次数。 open_file_cache_min_uses 1; # 设置打开文件缓存的最大条目数和不活跃条目的过期时间。 open_file_cache max=100000 inactive=60s; # 允许每个连接处理的最大请求数。 keepalive_requests 100000; # 开启gzip压缩。 gzip on; # 向响应头添加 \"Vary: Accept-Encoding\"，以便代理服务器能正确处理压缩内容。 gzip_vary on; # 定义需要进行gzip压缩的类型 gzip_types text/css text/javascript text/xml text/plain text/x-component application/javascript application/x-javascript application/json application/xml application/rss+xml application/atom+xml font/truetype font/opentype application/vnd.ms-fontobject image/svg+xml; # 对代理请求的响应启用 gzip 压缩，如果响应头部包含 expired、no-cache、no-store、private 或 auth。 gzip_proxied expired no-cache no-store private auth; # 只有响应体大于或等于 512 字节时才进行压缩。 gzip_min_length 512; # 禁止对 IE6 浏览器进行 gzip 压缩。 gzip_disable msie6; # 设置压缩等级，范围是 1 到 9，数字越大压缩比越高，但消耗的 CPU 资源也越多。 gzip_comp_level 5; # 设置压缩缓冲区的大小和数量。 gzip_buffers 4 16k; # 文件下载优化 client_body_buffer_size 128K; client_max_body_size 100M; client_header_buffer_size 1k; large_client_header_buffers 4 4k; # http服务 server { # 监听IPv4的80端口 listen 80; # 监听IPv6的80端口 listen [::]:80; # 设置服务器名称，下划线表示匹配所有未指定的域名。 server_name lcjdbsc.com; # 重定向跳转至https return 301 https://$server_name$request_uri; } # https服务 server { # 启用SSL和HTTP2协议。 listen 443 ssl http2; listen [::]:443 ssl http2; server_name lcjdbsc.com; # 指定SSL证书及其私钥的位置。 ssl_certificate /etc/nginx/www/ssl/lcjdbsc.com.pem; ssl_certificate_key /etc/nginx/www/ssl/lcjdbsc.com.key; # 设置SSL会话缓存1m 表示1MB缓存空间。 ssl_session_cache shared:SSL:1m; # 设置SSL会话超时时间。 ssl_session_timeout 10m; # 设置使用的加密套件 ssl_ciphers \"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384\"; # 优先使用服务器端指定的加密算法。 ssl_prefer_server_ciphers on; # 设置网站根目录。 root /etc/nginx/www/zhsq/dist; location /api/ { proxy_pass http://192.168.151.11:8003/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } } root和alias的区别 相同点： root和alias都可以在location块中使用，指定请求资源的真实路径 不同点： 1、作用范围： root：可以在server、http、location块中使用， alias：只能在location中使用 2、规则不同： root：会将location块匹配的路径都加在真实路径的后面 alias：会将location块匹配的路径后的内容加在真实路径的后面 比如：访问http://www.xxx.com/action/logo.png root 实际访问的操作系统上的文件路径是：/ac/image/action/logo.png location /action { root /ac/image; } alias 实际访问的操作系统上的文件路径是：/ac/image/logo.png location /action { alias /ac/image; } 三，创建并运行容器 # 创建并启动容器 docker-compose up -d xxx # 停止并删除容器 docker-compose down xxx # 开启容器 docker-compose start xxx # 重启容器 docker-compose restart xxx # 开启容器 docker-compose start xxx # 停止容器 docker-compose stop xxx # 删除容器 docker-compose rm xxx # 进入容器内部 docker-compose exec xxx bash "},"第9章 Docker Software/9.2 部署MySQL.html":{"url":"第9章 Docker Software/9.2 部署MySQL.html","title":"9.2 部署MySQL","keywords":"","body":"一，拉取镜像 docker pull mysql:8.0.20 二，创建docker-compose.yml version: '3.8' services: mysql: # mysql容器 image: mysql:8.4.0 # 指定镜像 container_name: mysql_container # 容器名为mysql_container restart: always # 重启策略: 容器退出时总是重启容器 privileged: true # 设置容器的权限为root networks: db_network: ipv4_address: 172.18.0.2 volumes: # 挂载文件 - type: bind source: ./mysql/my.cnf target: /etc/mysql/my.cnf - type: bind source: /etc/localtime target: /etc/localtime - type: volume source: mysql_volume target: /var/lib/mysql environment: MYSQL_ROOT_PASSWORD: \"123qwe!@#\" # 设置root用户的密码 MYSQL_ROOT_HOST: \"localhost\" # 设置访问地址 TZ: Asia/Shanghai # 指定时区 ports: - 8306:3306 # 映射端口 volumes: mysql_volume: external: true name: mysql networks: db_network: external: true name: db_net 创建挂载目录 # 用于存放数据 mkdir /home/compose/mysql/data # 用于存放mysql的配置文件 mkdir /home/compose/mysql/my.cnf 创建配置文件my.cnf：vim /home/compose/mysql/my.cnf # MySQL 8.0.20 配置文件 [mysqld] # 设置MySQL的数据目录 datadir=/var/lib/mysql # 禁用DNS反向解析，提高性能 skip-name-resolve # 设置默认存储引擎 default-storage-engine=InnoDB # 设置默认认证插件，使用传统认证插件 default_authentication_plugin=mysql_native_password # 设置SQL模式，不严格模式 sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION # 设置最大连接数，根据实际需求调整 max_connections=1000 # 当达到最大连接数时，允许的最大临时连接数 max_connect_errors=10000 # 实现大小写不敏感配置（数据库服务器初始化后，就不能再修改了） lower_case_table_names=1 # 设置字符集 character-set-server=utf8mb4 collation-server=utf8mb4_unicode_ci # 设置二进制日志bin-log # 数据库唯一ID，主从的标识号绝对不能重复。 server-id=1 # 开启bin-log，并指定文件目录和文件名前缀。 log-bin=mysql-bin # 二进制日志格式，row表示基于行的复制 binlog_format=row # 设置bin-log的过期天数，到期会自动删除，默认：30天 expire_logs_days=7 # 设置bin-log单个文件大小 max_binlog_size=100M # InnoDB相关设置 # InnoDB缓冲池大小，建议设置为物理内存的75%左右 innodb_buffer_pool_size=4G # InnoDB缓冲池实例数量，根据缓冲池大小自动调整 innodb_buffer_pool_instances=8 # 分配给InnoDB日志文件的大小，通常为1/4的innodb_buffer_pool_size innodb_log_file_size=1G # InnoDB刷新日志到磁盘的策略，1表示每次事务提交都写入磁盘 innodb_flush_log_at_trx_commit=1 # InnoDB表空间管理方式，file-per-table表示每个表使用单独的表空间 innodb_file_per_table=1 # 设置临时表的最大大小 tmp_table_size=64M max_heap_table_size=64M # 设置允许的最大包大小 max_allowed_packet=16M # 设置排序缓冲区大小 sort_buffer_size=2M # 设置读取缓冲区大小 read_buffer_size=2M # 设置读取随机数据块的缓冲区大小 read_rnd_buffer_size=8M # 设置连接超时时间 wait_timeout=28800 # 连接空闲超时时间，单位为秒 interactive_timeout=28800 # 交互式连接空闲超时时间，单位为秒 # 设置InnoDB在线DDL操作的性能模式 innodb_online_alter_log_max_size=1G # 在线DDL操作的最大日志大小 # 设置InnoDB缓冲池预热 innodb_buffer_pool_dump_at_shutdown=ON # 关机时导出缓冲池状态 innodb_buffer_pool_load_at_startup=ON # 启动时加载缓冲池状态 # 设置InnoDB统计信息持久化 innodb_stats_persistent=ON # 开启统计信息持久化 # 设置安全性和稳定性 symbolic-links=0 # 禁用符号链接 default_password_lifetime=0 # 禁用密码过期 secure-file-priv=/var/lib/mysql # 限制文件导入导出路径 [client] default-character-set=utf8mb4 [mysql] default-character-set=utf8mb4 三，创建并运行容器 # 创建并启动容器 docker-compose up -d xxx # 停止并删除容器 docker-compose down xxx # 开启容器 docker-compose start xxx # 重启容器 docker-compose restart xxx # 开启容器 docker-compose start xxx # 停止容器 docker-compose stop xxx # 删除容器 docker-compose rm xxx # 进入容器内部 docker-compose exec xxx bash 四，实现主从复制 设置master数据库my.cnf # 数据库唯一ID，主从的标识号绝对不能重复。 server-id=1 # 开启bin-log，并指定文件目录和文件名前缀。 log-bin=mysql-bin # 二进制日志格式，row表示基于行的复制 binlog_format=row # 设置bin-log的过期天数，到期会自动删除，默认：30天 expire_logs_days=7 # 设置bin-log单个文件大小 max_binlog_size=100M master设置数据同步权限 # 创建用户并设置密码 CREATE USER 'ywc'@'%' IDENTIFIED WITH mysql_native_password BY '123456'; # 配置从库用户连接主库的信息 GRANT REPLICATION SLAVE ON *.* TO 'ywc'@'%'; # 刷新配置 flush privileges; # 查看主库master状态 show master status; 设置slave数据库my.cnf #设置从服务器id，必须于主服务器不同 server-id=2 #启动MySQ二进制日志系统 log-bin=mysql-bin #需要同步的数据库名。如果不指明同步哪些库，就去掉这行，表示所有库的同步（除了ignore忽略的库）。 replicate-do-db=demo #不同步test数据库。 replicate-ignore-db=mysql #跳过所有的错误，继续执行复制操作 slave-skip-errors=all 配置主从同步指令 #执行同步前，要先关闭slave stop slave； change master to master_host='192.168.151.12',master_user='ywc', master_password='123456', master_port=13306, master_log_file='mysql-bin.000004', master_log_pos=1602; #开启slave（如果执行后报错，可以先执行：reset slave） start slave; #查看slave状态，当IO和SQL线程的状态均为Yes时，则表示主从同步已经实现。 show slave status \\G; "},"第9章 Docker Software/9.3 部署Redis.html":{"url":"第9章 Docker Software/9.3 部署Redis.html","title":"9.3 部署Redis","keywords":"","body":"一，拉取镜像 docker pull redis:4.0.8 二，创建docker-compose.yml version: '3' services: redis: # redis容器 image: redis:4.0.8 # 指定镜像 container_name: redis_container # 容器名为redis_container restart: always # 重启策略: 容器退出时总是重启容器 volumes: # 挂载文件 - /home/compose/redis/redis.conf:/etc/redis/redis.conf - /home/compose/redis/data:/data command: /bin/bash -c \"redis-server /etc/redis/redis.conf\" # 容器启动后执行redis.conf environment: TZ: Asia/Shanghai # 指定时区 ports: - 6379:6379 # 映射端口 创建挂载目录 # 用于存放数据 mkdir /home/compose/redis/data # 用于存放redis的配置文件 mkdir /home/compose/redis/redis.conf 创建配置文件redis.conf：vim /home/compose/redis/redis.conf # 绑定的主机地址，不要绑定容器的本地127.0.0.1地址，因为这样就无法在容器外部访问 bind 0.0.0.0 #默认yes，开启保护模式，限制为本地访问 protected-mode no # Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no # 数据库个数（可选），我修改了这个只是查看是否生效。 databases 16 # 指定Redis监听端口，默认端口为6379 port 6379 # 持久化 appendonly yes # 设置密码 requirepass 123qwe!@# 三，创建并运行容器 # 创建并启动容器 docker-compose up -d xxx # 停止并删除容器 docker-compose down xxx # 开启容器 docker-compose start xxx # 重启容器 docker-compose restart xxx # 开启容器 docker-compose start xxx # 停止容器 docker-compose stop xxx # 删除容器 docker-compose rm xxx # 进入容器内部 docker-compose exec xxx bash "},"第10章 Docker Manager/10.1 portainer.html":{"url":"第10章 Docker Manager/10.1 portainer.html","title":"10.1 portainer","keywords":"","body":"portainer介绍 Portainer是Docker的图形化管理工具，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm集群和服务等集中管理和操作、登录用户管理和控制等功能。功能十分全面，基本能满足中小型单位对容器管理的全部需求。 portainer安装 拉取镜像 docker pull portainer-ce:2.16.2 编辑docker-compose.yml version: '3' services: portainer: image: portainer-ce:2.16.2 container_name: portainer_container restart: always volumes: - /var/run/docker.sock:/var/run/docker.sock - /home/compose/portainer/db:/data ports: - 9000:9000 - 8000:8000 "}}